# 📋 Caffis Platform - Architettura Completa

## 🏗️ OVERVIEW GENERALE

### Struttura Microservizi
```
Caffis Platform
├── Main App (caffis-main-app/)
│   ├── Client (Next.js + React) → Porto 3000
│   └── Server (Node.js + Express + PostgreSQL) → Porto 5000
├── Map Service (caffis-map-service/)
│   ├── Backend (Node.js + Socket.IO + Redis) → Porto 5001  
│   └── Frontend (React Components Widget)
├── Chat Service (caffis-chat-service/) → Porto 5002 [FUTURO]
├── Notification Service (caffis-notification-service/) → Porto 5003 [FUTURO]
└── Shared Infrastructure
    ├── PostgreSQL Database → Porto 5432
    ├── Redis Cache → Porto 6379
    └── Nginx Load Balancer → Porto 80
```

---

## 🗺️ MAP SERVICE - DETTAGLIO ARCHITETTURALE

### Perché Backend + Frontend separati?

#### MAP BACKEND (Node.js Microservice)
**Responsabilità:**
- ✅ **Geolocalizzazione real-time** via Socket.IO
- ✅ **Cache Redis** per location data e performance
- ✅ **Business Logic** per matching utenti nelle vicinanze
- ✅ **API REST** per operazioni CRUD mappa
- ✅ **Authentication** JWT validation
- ✅ **Broadcast Events** real-time a utenti connessi

**Tech Stack:**
- Node.js + Express
- Socket.IO per WebSocket
- Redis per caching
- JWT per auth
- Geolib per calcoli geografici

#### MAP FRONTEND (React Widget)
**Responsabilità:**
- ✅ **UI Widget** draggable/resizable sulla dashboard
- ✅ **Mapbox GL** integration per rendering mappa
- ✅ **Socket.IO Client** per real-time updates
- ✅ **User Interactions** (click markers, send invites)
- ✅ **State Management** per posizioni utenti
- ✅ **Responsive Design** mobile-ready

**Tech Stack:**
- React Components
- Mapbox GL JS
- Socket.IO Client
- Framer Motion per animazioni
- CSS Modules

---

## 🔄 COMMUNICATION FLOW

### Real-time Data Flow
```
1. User Dashboard → Click "Pronto a Connettersi!"
2. Map Widget → Requests GPS permission
3. Frontend → WebSocket connect to Map Service :5001
4. Map Backend → Validates JWT + stores location in Redis
5. Redis → Caches location with TTL (5 min)
6. Socket.IO → Broadcasts to users in same city
7. Other Users → Receive real-time position updates
8. Mapbox → Renders markers with live positions
9. User Clicks Marker → Profile popup with invite actions
10. Invite Sent → Socket.IO delivers to target user
```

### API Communication
```
Main App Frontend ←→ Main App Backend (REST)
Map Widget ←→ Map Service Backend (Socket.IO + REST)
Map Service ←→ Redis Cache (location data)
Map Service ←→ Main App Backend (user profiles via REST)
```

---

## 📁 DIRECTORY STRUCTURE

### Root Project Structure
```
caffis-platform/
├── docker-compose.yml                 # Orchestrazione completa
├── .env.global                       # Variabili globali
├── nginx/                            # Load Balancer
│   ├── nginx.conf
│   └── ssl/
├── caffis-main-app/                  # App Principale (ESISTENTE)
│   ├── client/                       # Frontend Next.js
│   ├── server/                       # Backend Node.js
│   └── docker-compose.yml
├── caffis-map-service/               # Microservizio Mappa (NUOVO)
│   ├── backend/                      # Map Backend
│   ├── frontend/                     # Map Widget Components
│   ├── nginx/                        # Static assets server
│   ├── redis/                        # Redis config
│   └── docker-compose.yml
├── caffis-chat-service/              # Chat Service (FUTURO)
└── caffis-notification-service/      # Notifications (FUTURO)
```

### Map Service Structure Dettagliata
```
caffis-map-service/
├── backend/
│   ├── src/
│   │   ├── controllers/              # API endpoints
│   │   │   ├── mapController.js
│   │   │   └── locationController.js
│   │   ├── services/                 # Business logic
│   │   │   ├── redisService.js
│   │   │   ├── socketService.js
│   │   │   ├── locationService.js
│   │   │   └── geoService.js
│   │   ├── middleware/               # Auth, validation, etc.
│   │   │   ├── authMiddleware.js
│   │   │   └── rateLimitMiddleware.js
│   │   ├── routes/                   # Route definitions
│   │   │   ├── mapRoutes.js
│   │   │   └── healthRoutes.js
│   │   ├── utils/                    # Utilities
│   │   │   ├── logger.js
│   │   │   └── geoUtils.js
│   │   └── config/                   # Configuration
│   │       └── database.js
│   ├── tests/                        # Test files
│   ├── Dockerfile                    # Docker backend
│   ├── package.json
│   ├── server.js                     # Entry point
│   └── .env.example
├── frontend/
│   ├── components/                   # React Components
│   │   ├── DraggableMapWidget.jsx    # Main widget
│   │   ├── MapboxMap.jsx            # Mapbox integration
│   │   ├── UserMarker.jsx           # User markers
│   │   ├── UserProfilePopup.jsx     # Profile modals
│   │   └── AvailabilityToggle.jsx   # Status toggle
│   ├── hooks/                        # Custom React hooks
│   │   ├── useMapSocket.js          # Socket.IO hook
│   │   ├── useGeolocation.js        # GPS hook
│   │   └── useMapbox.js             # Mapbox hook
│   ├── services/                     # API services
│   │   ├── mapApi.js                # REST API calls
│   │   └── socketClient.js          # Socket client
│   ├── styles/                       # CSS styles
│   │   ├── map-widget.css
│   │   └── mapbox-custom.css
│   ├── utils/                        # Utilities
│   │   └── coordinates.js
│   ├── Dockerfile                    # Docker frontend
│   ├── package.json
│   ├── webpack.config.js
│   └── index.js                      # Export entry
├── nginx/
│   ├── nginx.conf                    # Static server config
│   └── Dockerfile
├── redis/
│   └── redis.conf                    # Redis configuration
├── docker-compose.yml               # Map service orchestration
├── Makefile                          # Development commands
└── README.md
```

---

## 🐳 DOCKER ARCHITECTURE

### Container Strategy
```
╭─────────────────────────────────────────────────────────╮
│                  DOCKER COMPOSE STACK                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │
│  │ MAIN APP    │  │ MAP SERVICE │  │   NGINX     │    │
│  │             │  │             │  │ Load Balancer│    │
│  │ Frontend    │  │ Backend     │  │             │    │
│  │ :3000       │  │ :5001       │  │ :80         │    │
│  │             │  │             │  │             │    │
│  │ Backend     │  │ Frontend    │  │             │    │
│  │ :5000       │  │ Components  │  │             │    │
│  └─────────────┘  └─────────────┘  └─────────────┘    │
│         │                 │               │           │
│         └─────────────────┼───────────────┘           │
│                           │                           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │
│  │ POSTGRESQL  │  │    REDIS    │  │   MONGODB   │    │
│  │ Main DB     │  │ Map Cache   │  │ Chat DB     │    │
│  │ :5432       │  │ :6379       │  │ :27017      │    │
│  └─────────────┘  └─────────────┘  └─────────────┘    │
│                                                         │
╰─────────────────────────────────────────────────────────╯
```

### Network Isolation
```
Networks:
├── frontend-network (public access)
│   ├── Nginx Load Balancer
│   ├── Main App Frontend
│   └── Map Service Frontend
├── backend-network (internal only)
│   ├── Main App Backend
│   ├── Map Service Backend
│   └── Chat Service Backend
└── database-network (internal only)
    ├── PostgreSQL
    ├── Redis
    └── MongoDB
```

---

## 🔐 SECURITY ARCHITECTURE

### Authentication Flow
```
1. User Login → Main App Backend
2. JWT Token Generated → Stored in Frontend
3. Map Widget Request → Includes JWT in header
4. Map Service → Validates JWT with same secret
5. WebSocket Connection → JWT in handshake auth
6. Real-time Communication → Authorized user only
```

### Security Layers
- ✅ **JWT Authentication** shared between services
- ✅ **Rate Limiting** per API endpoint
- ✅ **CORS Protection** configured per service
- ✅ **Helmet Security Headers** 
- ✅ **Input Validation** with Joi schemas
- ✅ **Network Isolation** via Docker networks
- ✅ **HTTPS Termination** at Nginx level

---

## 📊 DATA FLOW & CACHING

### Redis Caching Strategy
```
Keys Structure:
├── location:{userId}           # User location (TTL: 5min)
├── city:{cityName}            # Users in city (TTL: 5min)  
├── coffee_shops:{cityName}    # Coffee shops (TTL: 1hr)
└── user_profile:{userId}      # User profiles (TTL: 30min)
```

### Database Distribution
```
PostgreSQL (Main App):
├── Users & Authentication
├── User Preferences & Onboarding
├── Coffee Invites & Events
└── User Relationships

Redis (Map Service):
├── Real-time Locations
├── Active User Sessions
├── City-based User Groups
└── Coffee Shop Data Cache

MongoDB (Chat Service - Future):
├── Messages & Conversations
├── Message Attachments
└── Chat Room Metadata
```

---

## 🚀 DEPLOYMENT STRATEGY

### Development Environment
```bash
# Start individual services
docker-compose up main-app-backend postgres
docker-compose up map-service redis  
docker-compose up chat-service mongo

# Start entire platform
docker-compose up --build
```

### Production Environment
```bash
# Scaled deployment
docker-compose up --scale map-service-backend=3
docker-compose up --scale chat-service-backend=2

# With monitoring
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d
```

### CI/CD Pipeline
```
1. Git Push → GitHub/GitLab
2. Automated Tests → Jest + Supertest
3. Docker Build → Multi-stage builds
4. Image Push → Docker Registry
5. Deploy → Kubernetes/Docker Swarm
6. Health Checks → Service monitoring
7. Rollback → If health checks fail
```

---

## 📈 SCALABILITY DESIGN

### Horizontal Scaling Points
- ✅ **Map Service Backend** → Multiple instances behind load balancer
- ✅ **Chat Service** → Stateless with Redis session store
- ✅ **Database Read Replicas** → For read-heavy operations
- ✅ **Redis Clustering** → For high-availability caching
- ✅ **CDN Integration** → For static assets and map tiles

### Performance Optimizations
- ✅ **Connection Pooling** for database connections
- ✅ **Redis Pipeline** for batch operations
- ✅ **WebSocket Connection Reuse** 
- ✅ **Gzip Compression** for API responses
- ✅ **Map Tile Caching** for Mapbox optimization

---

## 🔧 DEVELOPMENT WORKFLOW

### Local Development Setup
```
1. Clone repo
2. Copy .env files
3. docker-compose up postgres redis
4. npm run dev (each service)
5. Hot reload enabled
```

### Testing Strategy
```
├── Unit Tests → Jest + React Testing Library
├── Integration Tests → Supertest + Socket.IO testing
├── E2E Tests → Cypress for user flows
└── Load Tests → Artillery for WebSocket performance
```

### Monitoring & Observability
```
├── Health Checks → /health endpoints
├── Metrics → Prometheus + Grafana
├── Logging → Winston + ELK Stack
├── Error Tracking → Sentry integration
└── Performance → APM monitoring
```

---

## 📱 MOBILE STRATEGY

### Progressive Web App (PWA)
- ✅ **Service Worker** for offline functionality
- ✅ **Web Manifest** for mobile installation
- ✅ **Push Notifications** for coffee invites
- ✅ **Geolocation API** for accurate positioning
- ✅ **Touch Gestures** for map interactions

### Future Native App Integration
- ✅ **React Native** for mobile apps
- ✅ **Shared API Layer** across web and mobile
- ✅ **WebSocket Reuse** for real-time features
- ✅ **Offline-first** data synchronization

---

## 🎯 ROADMAP & FUTURE FEATURES

### Phase 1 (Current) - Core Map Functionality
- ✅ Real-time user locations
- ✅ Coffee shop markers
- ✅ User profile popups
- ✅ Basic invite system

### Phase 2 - Enhanced Social Features
- 🔄 Real-time chat integration
- 🔄 Advanced user matching algorithms
- 🔄 Coffee shop ratings & reviews
- 🔄 Group meetup organization

### Phase 3 - Advanced Features
- 🔄 AI-powered recommendations
- 🔄 Loyalty program integration
- 🔄 Payment system for coffee shops
- 🔄 Advanced analytics dashboard

### Phase 4 - Scale & Performance
- 🔄 Multi-city expansion
- 🔄 Kubernetes orchestration
- 🔄 Global CDN deployment
- 🔄 Advanced monitoring & alerting

---

## 💡 KEY DESIGN DECISIONS

### Why Microservices?
1. **Independent Scaling** → Map service can scale separately
2. **Technology Diversity** → Best tool for each job
3. **Team Autonomy** → Different teams can work independently  
4. **Fault Isolation** → Map failure doesn't break main app
5. **Deployment Flexibility** → Deploy services independently

### Why Redis for Map Data?
1. **Speed** → Sub-millisecond response times
2. **TTL Support** → Automatic cleanup of stale locations
3. **Pub/Sub** → Real-time broadcasting capabilities
4. **Geospatial Commands** → Built-in geographic operations
5. **High Availability** → Clustering and persistence options

### Why Socket.IO for Real-time?
1. **Browser Compatibility** → WebSocket with fallbacks
2. **Room Management** → Easy city-based grouping
3. **Event-based** → Clean separation of concerns
4. **Reconnection Logic** → Automatic reconnection handling
5. **Scaling Support** → Redis adapter for multiple instances

---

Questa architettura garantisce:
✅ **Scalabilità** → Ogni servizio scala indipendentemente
✅ **Manutenibilità** → Codice modulare e ben organizzato
✅ **Performance** → Cache intelligente e real-time ottimizzato
✅ **Sicurezza** → Autenticazione distribuita e network isolation
✅ **Developer Experience** → Hot reload e easy debugging
✅ **Production Ready** → Monitoring, logging, health checks